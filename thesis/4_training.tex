\section{Training}



\subsection{Dataset}

Lichess is a free online site to play chess, and thankfully it provides a CC0 database \cite{lichessdb} with all the games ever played on the site. It consists of serveral compressed PGN files\footnote{Portable Game Notation: a textual format to store chess games (moves and metadata)} splitted by month since 2013, that add up to $1.71$TB compressed. The whole database contains over 5.5 billion games, that equates to around 200 billion positions. In practice, that many positions are too much to handle so I'll use only a fraction of them and take only one sample per game to maximize the diversity of positions.

% The Lichess database also provides a database of puzzles
% hablar de esto en otro lado (results? eval?)

\subsection{Filtering}

A single game can have lots of positions, most of which are shared with millions of other games. This is a problem of its own, trying to keep samples 


\subsection{Methods}



\subsubsection{Stockfish evaluations}

The main method to train the network will use the latest Stockfish evaluations as target. The objective is to train the network to predict the evaluation of a position as Stockfish would do.

First, we need to generate the training data, that means running the latest Stockfish on lots of positions and saving the evaluation. This is a very expensive process, depending on the depth of the search and the number of positions.


decir que la data de entrenamiento no es la misma. SF original usaba datos de handcrafted, hoy en dia usa de LC0. Nosotros usamos de Lichess, computada por el SF moderno
decir que no usamos el outcome de la partida para el score


\subsubsection{PQR triplets}

This is an additional technique we wanted to try, described in \cite{dlchess:2014}. Remember that we are trying to obtain a function $f$ (the model) to give an evaluation of a position. The method is based in the assumption that players make optimal or near-optimal moves most of the time, even if they are amateurs.

\begin{enumerate}
\item For two position in succession $p \rightarrow q$  observed in the game, we will have $f(p) \neq f(q)$.
\item Going from $p$, not to $q$, but to a \textit{random} position $p \rightarrow r$, we must have $f(r) > f(q)$ because the random move is better for the next player and worse for the player that made the move.
\end{enumerate}

With infinite compute, $f$ would be the result of running minimax to the end of the game, since minimax always finds optimal moves.

\subsection{Metrics}

asd \cite{nnue:2018}

\subsection{Setup}

arquitectura, rust, pasado de samples
